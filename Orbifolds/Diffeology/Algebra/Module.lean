import Orbifolds.Diffeology.Algebra.Group

/-!
# Smooth modules
This file introduces diffeological modules and the "fine diffeology",
the finest diffeology turning a given module into a diffeological module.
This is comparable to `Topology.Algebra.Module.ModuleTopology`, although the file
structure and naming are different because Mathlib (at the time of writing) does not have a
`TopologicalModule` class comparable to the `DiffeologicalVectorSpace` class introduced here.

While in practice we mostly care about diffeological vector spaces over `‚Ñù`, we work over
general rings here just in case.

Main definitions / results:
* `DiffeologicalModule R X`: typeclass saying that the diffeology and `R`-module structures
  on `X` are compatible, in that addition, negation and scalar multiplication is smooth
* arbitrary products of diffeological modules are again diffeological modules
* diffeologies induced by linear maps to diffeological modules are module diffeologies
* `ModuleDiffeology R X`: the type of `R`-module diffeologies on `X`. Forms a complete lattice.
* `fineDiffeology R X`: the finest diffeology on `X` making it into a topological `R`-module.
* `fineDiffeology_eq_euclideanDiffeology`: on finite-dimensional real vector spaces, the fine
  diffeology agrees with the standard diffeology for any choice of norm

## TODO
* the fine diffeology is generated by all linear plots
* explicit characterisation of plots of the fine diffeology
* results about the D-topology of the fine diffeology
* is the fine diffeology preserved under products?
-/

/-- A diffeological ring is a ring in which addition, negation and multiplication are smooth. -/
class DiffeologicalRing (R : Type*) [DiffeologicalSpace R] [Ring R] extends
    DiffeologicalAddGroup R, DSmoothMul R : Prop

/-- The main example we care about: `‚Ñù` is a diffeological ring. -/
instance : DiffeologicalRing ‚Ñù where
  dsmooth_add := contDiff_add.dsmooth
  dsmooth_neg := contDiff_neg.dsmooth
  dsmooth_mul := contDiff_mul.dsmooth

/-- A diffeological module over a diffeological ring is a module for which addition, negation
  and scalar multiplication are smooth. -/
class DiffeologicalModule (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [DiffeologicalSpace X] [AddCommGroup X] [Module R X] extends
    DiffeologicalAddGroup X, DSmoothSMul R X : Prop

/-- Normed spaces with their natural diffeologies are diffeological vector spaces. -/
instance (X : Type*) [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [DiffeologicalSpace X]
    [ContDiffCompatible X] : DiffeologicalModule ‚Ñù X where
  dsmooth_add := contDiff_add.dsmooth
  dsmooth_neg := contDiff_neg.dsmooth
  dsmooth_smul := contDiff_smul.dsmooth

example {n : ‚Ñï} : DiffeologicalModule ‚Ñù (Eucl n) := inferInstance

/-- Every linear map from `Eucl n` into a diffeological vector space is a plot. -/
lemma LinearMap.isPlot (X : Type*) [AddCommGroup X] [Module ‚Ñù X] [DiffeologicalSpace X]
    [DiffeologicalModule ‚Ñù X] {n : ‚Ñï} (p : Eucl n ‚Üí‚Çó[‚Ñù] X) : IsPlot p := by
  rw [show ‚áëp = fun x ‚Ü¶ ‚àë i, (EuclideanSpace.proj i x) ‚Ä¢ p (EuclideanSpace.single i 1) by
    ext x; convert (p.pi_apply_eq_sum_univ x) using 4; ext i; simp [eq_comm (b := i)]]
  refine (dsmooth_finset_sum _ fun i _ ‚Ü¶ ?_).isPlot
  exact (EuclideanSpace.proj (ùïú := ‚Ñù) i).contDiff.dsmooth.smul dsmooth_const

/-- If a diffeological module is locally compact with respect to the D-topology, then it is
  also a topological module. Notice that due to the D-topology not commuting with products
  in general, `X` being locally compact is necessary here to ensure that addition and scalar
  multiplication are continuous (although for the latter, `R` being locally compact would also
  suffice). An example of a diffeological vector space over `‚Ñù` whose addition is
  discontinuous is described in https://arxiv.org/abs/2205.09562. -/
example {R : Type*} [Ring R] [DiffeologicalSpace R] [TopologicalSpace R] [DTopCompatible R]
    [DiffeologicalRing R] {X : Type*} [AddCommGroup X] [Module R X] [DiffeologicalSpace X]
    [TopologicalSpace X] [DTopCompatible X] [DiffeologicalModule R X] [LocallyCompactSpace X] :
    ContinuousSMul R X ‚àß TopologicalAddGroup X :=
  ‚ü®inferInstance, inferInstance‚ü©

section

variable {R : Type*} [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]

/-- Binary products of diffeological modules are diffeological modules. -/
instance {X : Type*} [AddCommGroup X] [Module R X] [DiffeologicalSpace X]
    [DiffeologicalModule R X] {Y : Type*} [AddCommGroup Y] [Module R Y] [DiffeologicalSpace Y]
    [DiffeologicalModule R Y] :
    DiffeologicalModule R (X √ó Y) where

/-- Arbitrary products of diffeological modules are diffeological modules. -/
instance Pi.diffeologicalModule {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, AddCommGroup (X i)]
    [‚àÄ i, Module R (X i)] [‚àÄ i, DiffeologicalSpace (X i)] [‚àÄ i, DiffeologicalModule R (X i)] :
    DiffeologicalModule R (‚àÄ i, X i) where

/-- For any linear map to a diffeological module, the induced diffeology makes the
  domain a diffeological module too.
  TODO: replace the `Induction` hypothesis here with something that does not include
  injectivity, once that exists. In the meantime, see `diffeologicalModule_induced`. -/
protected theorem Induction.diffeologicalModule {X : Type*} [AddCommGroup X] [Module R X]
    [DiffeologicalSpace X] {Y : Type*} [AddCommGroup Y] [Module R Y] [DiffeologicalSpace Y]
    [DiffeologicalModule R Y] {F : Type*} [FunLike F X Y] [LinearMapClass F R X Y]
    (f : F) (hf : Induction f) : DiffeologicalModule R X :=
  { toDiffeologicalAddGroup := hf.diffeologicalAddGroup _
    toDSmoothSMul := hf.dsmoothSMul dsmooth_id (map_smul f _ _) }

theorem diffeologicalModule_induced {X : Type*} [AddCommGroup X] [Module R X] {Y : Type*}
    [AddCommGroup Y] [Module R Y] [DiffeologicalSpace Y] [DiffeologicalModule R Y]
    {F : Type*} [FunLike F X Y] [LinearMapClass F R X Y] (f : F) :
    @DiffeologicalModule R _ _ _ X (DiffeologicalSpace.induced f ‚Äπ_‚Ä∫) _ _ :=
  letI := DiffeologicalSpace.induced f ‚Äπ_‚Ä∫
  { toDiffeologicalAddGroup := diffeologicalAddGroup_induced f
    toDSmoothSMul := dsmoothSMul_induced f dsmooth_id (map_smul f _ _) }

theorem diffeologicalModule_sInf {X : Type*} [AddCommGroup X] [Module R X]
    {D : Set (DiffeologicalSpace X)} (h : ‚àÄ d ‚àà D, @DiffeologicalModule R _ _ _ X d _ _) :
    @DiffeologicalModule R _ _ _ X (sInf D) _ _ :=
  letI := sInf D
  { toDiffeologicalAddGroup := diffeologicalAddGroup_sInf fun d hd ‚Ü¶
      (h d hd).toDiffeologicalAddGroup
    toDSmoothSMul := dsmoothSMul_sInf <| fun d hd ‚Ü¶ (h d hd).toDSmoothSMul }

theorem diffeologicalModule_iInf {X : Type*} [AddCommGroup X] [Module R X] {Œπ : Type*}
    {D : Œπ ‚Üí DiffeologicalSpace X} (h' : ‚àÄ i, @DiffeologicalModule R _ _ _ X (D i) _ _) :
    @DiffeologicalModule R _ _ _ X (‚®Ö i, D i) _ _ := by
  rw [‚ÜêsInf_range]; exact diffeologicalModule_sInf (Set.forall_mem_range.mpr h')

theorem diffeologicalModule_inf {X : Type*} [AddCommGroup X] [Module R X]
    {d‚ÇÅ d‚ÇÇ : DiffeologicalSpace X}
    (h‚ÇÅ : @DiffeologicalModule R _ _ _ X d‚ÇÅ _ _) (h‚ÇÇ : @DiffeologicalModule R _ _ _ X d‚ÇÇ _ _) :
    @DiffeologicalModule R _ _ _ X (d‚ÇÅ ‚äì d‚ÇÇ) _ _ :=
  inf_eq_iInf d‚ÇÅ d‚ÇÇ ‚ñ∏ diffeologicalModule_iInf fun b ‚Ü¶ (by cases b <;> assumption)

end

/-!
### Lattice of module diffeologies
Analogous to `GroupDiffeology G`, we define for any `R`-module `X` the type
`ModuleDiffeology R X` of all diffeologies that turn `X` into a diffeological module.
This is interesting because, like `DiffeologicalSpace X`, `ModuleDiffeology R X` is
always a complete lattice - its top element is always the indiscrete diffeology, while its
bottom element is generally nontrivial. Note that the discrete diffeology is not a module
diffeology because scalar multiplication fails to be continuous.
-/

/-- A module diffeology on a module `X` is a diffeology with which `X` is a
  diffeological module. -/
structure ModuleDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] extends
    DiffeologicalSpace X, DiffeologicalModule R X

namespace ModuleDiffeology

variable {R : Type*} [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
  {X : Type*} [AddCommGroup X] [Module R X]

def toAddGroupDiffeology (d : ModuleDiffeology R X) : AddGroupDiffeology X :=
  ‚ü®d.toDiffeologicalSpace, d.toDiffeologicalModule.toDiffeologicalAddGroup‚ü©

/-- A version of the global `dsmooth_add` suitable for dot notation. -/
theorem dsmooth_add' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth fun p : X √ó X ‚Ü¶ p.1 + p.2 :=
  d.toAddGroupDiffeology.dsmooth_add'

/-- A version of the global `dsmooth_neg` suitable for dot notation. -/
theorem dsmooth_neg' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth (Neg.neg : X ‚Üí X) :=
  d.toAddGroupDiffeology.dsmooth_neg'

/-- A version of the global `dsmooth_smul` suitable for dot notation. -/
theorem dsmooth_smul' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth fun p : R √ó X ‚Ü¶ p.1 ‚Ä¢ p.2 := by
  letI := d.toDiffeologicalSpace
  haveI := d.toDiffeologicalModule
  exact dsmooth_smul

theorem toDiffeologicalSpace_injective :
    Function.Injective (toDiffeologicalSpace : ModuleDiffeology R X ‚Üí DiffeologicalSpace X) :=
  fun f g h ‚Ü¶ by cases f; cases g; congr

theorem toAddGroupDiffeology_injective :
    Function.Injective (toAddGroupDiffeology : ModuleDiffeology R X ‚Üí AddGroupDiffeology X) :=
  toDiffeologicalSpace_injective.of_comp (f := AddGroupDiffeology.toDiffeologicalSpace)

@[ext]
theorem ext' {d‚ÇÅ d‚ÇÇ : ModuleDiffeology R X} (h : d‚ÇÅ.1 = d‚ÇÇ.1) : d‚ÇÅ = d‚ÇÇ :=
  toDiffeologicalSpace_injective h

instance : PartialOrder (ModuleDiffeology R X) :=
  PartialOrder.lift toDiffeologicalSpace toDiffeologicalSpace_injective

theorem toDiffeologicalSpace_le {d‚ÇÅ d‚ÇÇ : ModuleDiffeology R X} :
    d‚ÇÅ.1 ‚â§ d‚ÇÇ.1 ‚Üî d‚ÇÅ ‚â§ d‚ÇÇ :=
  Iff.rfl

/-- The coarsest module diffeology that is finer than a given diffeology.
  Called `reflector` for the lack of a better name and because it is left-adjoint to
  `ModuleDiffeology.toDiffeologicalSpace`. -/
def reflector (d : DiffeologicalSpace X) : ModuleDiffeology R X :=
  ‚ü®sInf {d' | d ‚â§ d' ‚àß @DiffeologicalModule R _ _ _ X d' _ _},
    diffeologicalModule_sInf fun _ h ‚Ü¶ h.2‚ü©

lemma gc_toDiffeologicalSpace :
    GaloisConnection reflector (toDiffeologicalSpace (R := R) (X := X)) :=
  fun _ _ ‚Ü¶ ‚ü®fun h ‚Ü¶ (le_sInf fun _ h ‚Ü¶ h.1).trans (toDiffeologicalSpace_le.2 h),
    fun h ‚Ü¶ toDiffeologicalSpace_le.1 <| sInf_le ‚ü®h, toDiffeologicalModule _‚ü©‚ü©

/-- The galois insertion between `ModuleDiffeology R X` and `DiffeologicalSpace X` whose
  lower part sends each diffeology to the finest coarser module diffeology, and whose
  upper part sends each module diffeology to itself. -/
def gci_toDiffeologicalSpace :
    GaloisInsertion reflector (toDiffeologicalSpace (R := R) (X := X)) where
  gc := gc_toDiffeologicalSpace
  le_l_u _ := toDiffeologicalSpace_le.1 <| le_sInf fun _ h ‚Ü¶ h.1
  choice d hd := ‚ü®d, le_antisymm (le_sInf fun _ h ‚Ü¶ h.1) hd ‚ñ∏
    (reflector d).toDiffeologicalModule‚ü©
  choice_eq _ h := ext' <| le_antisymm (le_sInf fun _ h ‚Ü¶ h.1) h

/-- `R`-module diffeologies on `X` form a complete lattice. -/
instance : CompleteLattice (ModuleDiffeology R X) :=
  (gci_toDiffeologicalSpace).liftCompleteLattice

end ModuleDiffeology

/-!
### The fine diffeology
On any module `X` over a diffeological ring `R`, the fine diffeology is defined as the finest
diffeology making it into a topological module, i.e. the bottom element of
`ModuleDiffeology R X`. Although we do not show it here, the plots of this diffeology are
precisely those maps that locally restrict to smooth maps to finite-dimensional subspaces
of `X` with their standard diffeologies. In particular, on all finite-dimensional normed spaces
this coincides with the smooth diffeology given by the norm - see Zemmour's diffeology book
for more details.

It's not yet clear to me whether the D-topology of this diffeology always coincides with
the finest topology making `X` into a topological module - if it does, it might make sense to
redefine this to make the D-topology defeq to mathlib's `moduleTopology R X`.
-/

section FineDiffeology

/-- The finest diffeology turning a given module over a diffeological ring into a
  diffeological module. -/
def fineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] : DiffeologicalSpace X :=
  (‚ä• : ModuleDiffeology R X).toDiffeologicalSpace

/-- A typeclass asserting that the diffeology on `X` equals `fineDiffeology R X`. -/
class IsFineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X] : Prop where
  /-- Slightly awkward because all arguments are implicit - use `eq_fineDiffeology R X` instead. -/
  eq_fineDiffeology' : d = fineDiffeology R X

theorem eq_fineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X]
    [IsFineDiffeology R X] : d = fineDiffeology R X :=
  IsFineDiffeology.eq_fineDiffeology'

instance (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] :
    @IsFineDiffeology R _ _ _ X _ _ (fineDiffeology R X) :=
  letI := fineDiffeology R X; ‚ü®rfl‚ü©

instance (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [DiffeologicalSpace X] [IsFineDiffeology R X] :
    DiffeologicalModule R X :=
  eq_fineDiffeology R X ‚ñ∏ (‚ä• : ModuleDiffeology R X).toDiffeologicalModule

/-- The fine diffeology is finer than any other diffeology making `X` a diffeological module. -/
lemma fineDiffeology_le (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X]
    [DiffeologicalModule R X] : fineDiffeology R X ‚â§ d :=
  ModuleDiffeology.toDiffeologicalSpace_le.2
    (bot_le : (‚ä• : ModuleDiffeology R X) ‚â§ ‚ü®d, inferInstance‚ü©)

/-- Any linear map from a fine diffeological module to another diffeological module is smooth. -/
lemma LinearMap.dsmooth (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    {X : Type*} [AddCommGroup X] [Module R X] [DiffeologicalSpace X] [IsFineDiffeology R X]
    {Y : Type*} [AddCommGroup Y] [Module R Y] [DiffeologicalSpace Y] [DiffeologicalModule R Y]
    (f : X ‚Üí‚Çó[R] Y) : DSmooth f :=
  dsmooth_iff_le_induced.2 <| (eq_fineDiffeology R X (d := _)).trans_le <|
    @fineDiffeology_le R _ _ _ X _ _ (.induced f _) (diffeologicalModule_induced f)

/-- On finite-dimensional normed spaces, the fine diffeology equals the standard diffeology
  consisting of plots that are smooth with respect to the norm. Since the fine diffeology does
  not depend on any norm, this in particular shows that `euclideanDiffeology` does not actually
  depend on the choice of norm either. -/
lemma fineDiffeology_eq_euclideanDiffeology (X : Type*) [NormedAddCommGroup X] [NormedSpace ‚Ñù X]
    [FiniteDimensional ‚Ñù X] : fineDiffeology ‚Ñù X = euclideanDiffeology := by
  refine le_antisymm (@fineDiffeology_le ‚Ñù _ _ _ X _ _ (_) _) ?_
  rw [DiffeologicalSpace.le_iff']; intro n p hp
  let e := LinearEquiv.ofFinrankEq X (Eucl _) (finrank_euclideanSpace_fin.symm)
  rw [show p = e.symm ‚àò e ‚àò p by
    rw [‚Üê Function.comp_assoc]; convert p.id_comp.symm; exact e.toEquiv.symm_comp_self]
  let _ := fineDiffeology ‚Ñù X
  refine isPlot_reparam e.symm.toLinearMap.isPlot ?_
  exact (LinearMap.toContinuousLinearMap e.toLinearMap).contDiff.comp hp

instance {X : Type*} [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [FiniteDimensional ‚Ñù X]
    [DiffeologicalSpace X] [IsFineDiffeology ‚Ñù X] : ContDiffCompatible X := by
  rw [eq_fineDiffeology ‚Ñù X, fineDiffeology_eq_euclideanDiffeology X]
  infer_instance

instance {X : Type*} [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [FiniteDimensional ‚Ñù X]
    [DiffeologicalSpace X] [ContDiffCompatible X] : IsFineDiffeology ‚Ñù X := by
  constructor; rw [fineDiffeology_eq_euclideanDiffeology X]
  exact contDiffCompatible_iff_eq_euclideanDiffeology.1 (by assumption)

end FineDiffeology
