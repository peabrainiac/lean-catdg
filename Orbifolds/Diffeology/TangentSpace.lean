import Orbifolds.Diffeology.DDiffeomorph

/-!
# Internal tangent spaces

This file defines internal tangent spaces on diffeological spaces following
https://arxiv.org/abs/1411.5425; concretely, the tangent space at `x` is implemented as
a quotient of the direct sum of the domains of all plots sending `0` to `x`.

For this to be actually useful we will need to show that this agrees with the usual tangent
spaces of vector spaces and manifolds, which we have yet to do.

Main definitions / results:
* `preInternalTangentSpace x`: the direct sum of the domains of all plots sending `0` to `x`.
* `internalTangentSpace x`: the internal tangent space at `x`.
* `internalTangentMap f x`: the tangent map of `f` at `x` if `f` is (globally) smooth,
  and `0` otherwise.
* `internalTangentMap_id`, `internalTangentMap_comp`: lemmas showing that this is functorial.

Todo:
* namespace and shorten names of `internalTangentSpace` and `internalTangentMap`,
  maybe find some good abbreviations
* tangent spaces of discrete / indiscrete spaces
* tangent spaces of open subspaces
* tangent spaces of vector spaces
* tangent spaces of manifolds
* tangent maps of constant maps
* tangent maps of maps between vector spaces / manifolds
-/

universe u v

open DirectSum DiffeologicalSpace Classical

noncomputable section

variable {X Y Z : Type u} [DiffeologicalSpace X] [DiffeologicalSpace Y] [DiffeologicalSpace Z]

/-- The set of all plots in `X` that send `0` to `x`. -/
def DiffeologicalSpace.pointedPlots (x : X) : Set ((n : ℕ) × (Eucl n → X)) :=
  {p | IsPlot p.2 ∧ p.2 0 = x}

/-- The direct sum of the domains of all pointed plots to `x`.
  The actual internal tangent space is obtained as a quotient from this. -/
def preInternalTangentSpace (x : X) := ⨁ p : pointedPlots x, Eucl p.1.1

instance {x : X} : AddCommGroup (preInternalTangentSpace x) := by
  unfold preInternalTangentSpace; infer_instance

instance {x : X} : Module ℝ (preInternalTangentSpace x) := by
  unfold preInternalTangentSpace; infer_instance

/-- The internal tangent space of `X` at `x`, implemented here as the quotient of
  `preInternalTangentSpace x` by the subspace generated by some relations. -/
def internalTangentSpace (x : X) := preInternalTangentSpace x ⧸ Submodule.span ℝ
  {v : preInternalTangentSpace x | ∃ p q : pointedPlots x,
    ∃ f : DSmoothMap (Eucl p.1.1) (Eucl q.1.1), ∃ w : Eucl p.1.1,
      v = DirectSum.lof ℝ _ _ p w - DirectSum.lof ℝ _ _ q (fderiv ℝ f 0 w)}

instance {x : X} : AddCommGroup (internalTangentSpace x) := by
  unfold internalTangentSpace; infer_instance

instance {x : X} : Module ℝ (internalTangentSpace x) := by
  unfold internalTangentSpace; infer_instance

/-- Transports plots from `x` to `f x` for any smooth map `f`. -/
def DiffeologicalSpace.pointedPlots_map {f : X → Y} (hf : DSmooth f) (x : X) :
    pointedPlots x → pointedPlots (f x) :=
  fun p ↦ ⟨⟨p.1.1, f ∘ p.1.2⟩, (hf.comp p.2.1.dsmooth).isPlot, by simp [p.2.2]⟩

/-- The map `preInternalTangentSpace x →ₗ[ℝ] preInternalTangentSpace (f x)` that
  descents to the actual tangent map. Defined as `0` when `f` isn't smooth. -/
def preInternalTangentMap (f : X → Y) (x : X) :
    preInternalTangentSpace x →ₗ[ℝ] preInternalTangentSpace (f x) :=
  if hf : DSmooth f then
    toModule ℝ (pointedPlots x) (preInternalTangentSpace (f x)) fun p ↦
      lof ℝ (pointedPlots (f x)) (fun p ↦ Eucl p.1.1) (pointedPlots_map hf x p)
  else 0

/-- The internal tangent map of `f` at `x` when `f` is smooth, and `0` otherwise. -/
def internalTangentMap (f : X → Y) (x : X) :
    internalTangentSpace x →ₗ[ℝ] internalTangentSpace (f x) :=
  Submodule.mapQ _ _ (preInternalTangentMap f x) (by
    by_cases hf : DSmooth f
    · rw [← Submodule.map_le_iff_le_comap, Submodule.map_span_le]
      intro v ⟨p, q, g, w, hv⟩
      apply Submodule.subset_span
      use pointedPlots_map hf x p, pointedPlots_map hf x q, g, w
      simp only [preInternalTangentMap, hf, ↓reduceDIte, hv, map_sub]
      -- why does simp not use `toModule_lof`? possible defeq abuse in `preInternalTangentMap`?
      convert rfl using 2 <;> symm <;> convert toModule_lof ℝ _ _ using 2
    · simp_rw [preInternalTangentMap, eq_false hf, dite_false, Submodule.comap_zero]
      exact le_top)

@[simp]
lemma pointedPlots_map_id (x : X) : pointedPlots_map dsmooth_id x = id := by
  rfl

lemma pointedPlots_map_comp {f : X → Y} {g : Y → Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    pointedPlots_map (hg.comp hf) x = pointedPlots_map hg (f x) ∘ pointedPlots_map hf x  := by
  rfl

@[simp]
def preInternalTangentMap_id (x : X) : preInternalTangentMap id x = LinearMap.id := by
  simp_rw [preInternalTangentMap, dsmooth_id, dite_true, pointedPlots_map_id, id_eq]
  apply linearMap_ext; intro p; ext x
  simp

def preInternalTangentMap_comp {f : X → Y} {g : Y → Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    preInternalTangentMap (g ∘ f) x =
      preInternalTangentMap g (f x) ∘ₗ preInternalTangentMap f x := by
  simp_rw [preInternalTangentMap, hf, hg, hg.comp hf, dite_true, pointedPlots_map_comp hf hg]
  apply linearMap_ext; intro p; ext x'
  simp_rw [LinearMap.comp_assoc, LinearMap.comp_apply, Function.comp_apply, toModule_lof]
  -- again necessary because rewriting with `toModule_lof` directly doesn't work somehow
  symm; convert toModule_lof ℝ _ _ using 2

@[simp]
def internalTangentMap_id (x : X) : internalTangentMap id x = LinearMap.id := by
  simp_rw [internalTangentMap, preInternalTangentMap_id]
  exact Submodule.mapQ_id _

def internalTangentMap_comp {f : X → Y} {g : Y → Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    internalTangentMap (g ∘ f) x = internalTangentMap g (f x) ∘ₗ internalTangentMap f x := by
  simp_rw [internalTangentMap, preInternalTangentMap_comp hf hg]
  exact Submodule.mapQ_comp _ _ _ _ _ _ _
