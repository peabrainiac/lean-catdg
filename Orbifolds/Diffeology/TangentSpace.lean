import Orbifolds.Diffeology.Algebra.Module

/-!
# Internal tangent spaces

This file defines internal tangent spaces on diffeological spaces following
https://arxiv.org/abs/1411.5425; concretely, the tangent space at `x` is implemented as
a quotient of the direct sum of the domains of all plots sending `0` to `x`.

For this to be actually useful we will need to show that this agrees with the usual tangent
spaces of vector spaces and manifolds, which we have yet to do.

## Main definitions / results:
* `PreInternalTangentSpace x`: the direct sum of the domains of all plots sending `0` to `x`.
* `InternalTangentSpace x`: the internal tangent space at `x`.
* `internalTangentMap f x`: the tangent map of `f` at `x` if `f` is (globally) smooth,
  and `0` otherwise.
* `internalTangentMap_id`, `internalTangentMap_comp`: lemmas showing that this is functorial.

## TODO:
* namespace and shorten names of `InternalTangentSpace` and `internalTangentMap`,
  maybe find some good abbreviations
* tangent spaces of discrete / indiscrete spaces
* tangent spaces of open subspaces
* tangent spaces of vector spaces
* tangent spaces of manifolds
* tangent maps of constant maps
* tangent maps of maps between vector spaces / manifolds
-/

universe u v

open DirectSum DiffeologicalSpace Classical ContDiff

noncomputable section

variable {X Y Z : Type u} [DiffeologicalSpace X] [DiffeologicalSpace Y] [DiffeologicalSpace Z]

/-- The set of all plots in `X` that send `0` to `x`. -/
def DiffeologicalSpace.pointedPlots (x : X) : Set ((n : ‚Ñï) √ó (Eucl n ‚Üí X)) :=
  {p | IsPlot p.2 ‚àß p.2 0 = x}

/-- The direct sum of the domains of all pointed plots to `x`.
The actual internal tangent space is obtained as a quotient from this. -/
def PreInternalTangentSpace (x : X) := ‚®Å p : pointedPlots x, Eucl p.1.1

instance {x : X} : AddCommGroup (PreInternalTangentSpace x) := by
  unfold PreInternalTangentSpace; infer_instance

instance {x : X} : Module ‚Ñù (PreInternalTangentSpace x) := by
  unfold PreInternalTangentSpace; infer_instance

nonrec abbrev PreInternalTangentSpace.lof {x : X} (p : pointedPlots x) :
    Eucl p.1.1 ‚Üí‚Çó[‚Ñù] PreInternalTangentSpace x :=
  lof ‚Ñù (pointedPlots x) (fun p ‚Ü¶ Eucl p.1.1) p

/-- The internal tangent space of `X` at `x`, implemented here as the quotient of
`PreInternalTangentSpace x` by the subspace generated by some relations. -/
def InternalTangentSpace (x : X) := PreInternalTangentSpace x ‚ß∏ Submodule.span ‚Ñù
  {v : PreInternalTangentSpace x | ‚àÉ p q : pointedPlots x,
    ‚àÉ f : DSmoothMap (Eucl p.1.1) (Eucl q.1.1), ‚àÉ w : Eucl p.1.1,
      v = PreInternalTangentSpace.lof p w - PreInternalTangentSpace.lof q (fderiv ‚Ñù f 0 w)}

instance {x : X} : AddCommGroup (InternalTangentSpace x) := by
  unfold InternalTangentSpace; infer_instance

instance {x : X} : Module ‚Ñù (InternalTangentSpace x) := by
  unfold InternalTangentSpace; infer_instance

/-- The canonical linear map from the domain of any pointed plot into the tangent space. -/
def InternalTangentSpace.lof {x : X} (p : pointedPlots x) :
    Eucl p.1.1 ‚Üí‚Çó[‚Ñù] InternalTangentSpace x :=
  Submodule.mkQ _ ‚àò‚Çó PreInternalTangentSpace.lof p

lemma InternalTangentSpace.lof_comp_apply {x : X} (p : pointedPlots x) {m : ‚Ñï}
    {f : Eucl m ‚Üí Eucl p.1.1} (hf : ContDiff ‚Ñù ‚àû f) (hf' : f 0 = 0) (v : Eucl m):
    lof (x := x) ‚ü®‚ü®m, p.1.2 ‚àò f‚ü©, (isPlot_reparam p.2.1 hf:), (hf' ‚ñ∏ p.2.2:)‚ü© v =
      lof p (fderiv ‚Ñù f 0 v) := by
  refine (Submodule.Quotient.eq _).2 (Submodule.subset_span ?_)
  exact ‚ü®‚ü®‚ü®m, p.1.2 ‚àò f‚ü©, (isPlot_reparam p.2.1 hf:), (hf' ‚ñ∏ p.2.2:)‚ü©, p, ‚ü®f, hf.dsmooth‚ü©, v, rfl‚ü©

lemma InternalTangentSpace.lof_comp {x : X} (p : pointedPlots x) {m : ‚Ñï}
    {f : Eucl m ‚Üí Eucl p.1.1} (hf : ContDiff ‚Ñù ‚àû f) (hf' : f 0 = 0) :
    lof (x := x) ‚ü®‚ü®m, p.1.2 ‚àò f‚ü©, (isPlot_reparam p.2.1 hf:), (hf' ‚ñ∏ p.2.2:)‚ü© =
      lof p ‚àò‚Çó fderiv ‚Ñù f 0 := by
  ext v; exact lof_comp_apply p hf hf' _

/-- Transports plots from `x` to `f x` for any smooth map `f`. -/
def DiffeologicalSpace.pointedPlots_map {f : X ‚Üí Y} (hf : DSmooth f) (x : X) :
    pointedPlots x ‚Üí pointedPlots (f x) :=
  fun p ‚Ü¶ ‚ü®‚ü®p.1.1, f ‚àò p.1.2‚ü©, (hf.comp p.2.1.dsmooth).isPlot, by simp [p.2.2]‚ü©

/-- The map `PreInternalTangentSpace x ‚Üí‚Çó[‚Ñù] PreInternalTangentSpace (f x)` that
descents to the actual tangent map. Defined as `0` when `f` isn't smooth. -/
def preInternalTangentMap (f : X ‚Üí Y) (x : X) :
    PreInternalTangentSpace x ‚Üí‚Çó[‚Ñù] PreInternalTangentSpace (f x) :=
  if hf : DSmooth f then
    toModule ‚Ñù (pointedPlots x) (PreInternalTangentSpace (f x)) fun p ‚Ü¶
      lof ‚Ñù (pointedPlots (f x)) (fun p ‚Ü¶ Eucl p.1.1) (pointedPlots_map hf x p)
  else 0

/-- The internal tangent map of `f` at `x` when `f` is smooth, and `0` otherwise. -/
def internalTangentMap (f : X ‚Üí Y) (x : X) :
    InternalTangentSpace x ‚Üí‚Çó[‚Ñù] InternalTangentSpace (f x) :=
  Submodule.mapQ _ _ (preInternalTangentMap f x) (by
    by_cases hf : DSmooth f
    ¬∑ rw [‚Üê Submodule.map_le_iff_le_comap, Submodule.map_span_le]
      intro v ‚ü®p, q, g, w, hv‚ü©
      apply Submodule.subset_span
      use pointedPlots_map hf x p, pointedPlots_map hf x q, g, w
      simp only [preInternalTangentMap, hf, ‚ÜìreduceDIte, hv, map_sub]
      -- why does simp not use `toModule_lof`? possible defeq abuse in `preInternalTangentMap`?
      convert rfl using 2 <;> symm <;> convert toModule_lof ‚Ñù _ _ using 2
    ¬∑ simp_rw [preInternalTangentMap, eq_false hf, dite_false, Submodule.comap_zero]
      exact le_top)

@[simp]
lemma pointedPlots_map_id (x : X) : pointedPlots_map dsmooth_id x = id := by
  rfl

lemma pointedPlots_map_comp {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    pointedPlots_map (hg.comp hf) x = pointedPlots_map hg (f x) ‚àò pointedPlots_map hf x  := by
  rfl

@[simp]
lemma preInternalTangentMap_id (x : X) : preInternalTangentMap id x = LinearMap.id := by
  simp_rw [preInternalTangentMap, dsmooth_id, dite_true, pointedPlots_map_id, id_eq]
  apply linearMap_ext; intro p; ext x
  simp

lemma preInternalTangentMap_comp {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    preInternalTangentMap (g ‚àò f) x =
      preInternalTangentMap g (f x) ‚àò‚Çó preInternalTangentMap f x := by
  simp_rw [preInternalTangentMap, hf, hg, hg.comp hf, dite_true, pointedPlots_map_comp hf hg]
  apply linearMap_ext; intro p; ext x'
  simp_rw [LinearMap.comp_assoc, LinearMap.comp_apply, Function.comp_apply, toModule_lof]
  -- again necessary because rewriting with `toModule_lof` directly doesn't work somehow
  symm; convert toModule_lof ‚Ñù _ _ using 2

@[simp]
lemma internalTangentMap_id (x : X) : internalTangentMap id x = LinearMap.id := by
  simp_rw [internalTangentMap, preInternalTangentMap_id]
  exact Submodule.mapQ_id _

lemma internalTangentMap_comp {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : DSmooth f) (hg : DSmooth g) (x : X) :
    internalTangentMap (g ‚àò f) x = internalTangentMap g (f x) ‚àò‚Çó internalTangentMap f x := by
  simp_rw [internalTangentMap, preInternalTangentMap_comp hf hg]
  exact Submodule.mapQ_comp _ _ _ _ _ _ _

/-- The canonical map from a diffeological vector space to its internal tangent space at a point
`x`, sending any vector `v` to the internal tangent vector represented by the path
`t ‚Ü¶ x + t ‚Ä¢ v`. -/
def vectorSpaceToInternalTangentSpace [AddCommGroup X] [Module ‚Ñù X] [DiffeologicalAddGroup X]
    [DSmoothSMul ‚Ñù X] (x : X) : X ‚Üí‚Çó[‚Ñù] InternalTangentSpace x where
  toFun v := by
    refine InternalTangentSpace.lof ‚ü®‚ü®1, fun t ‚Ü¶ x + (t 0) ‚Ä¢ v‚ü©, ?_, by simp‚ü© (.single 0 1)
    -- TODO get fun_prop to handle this
    refine ((dsmooth_add_left x).comp ?_).isPlot
    refine dsmooth_smul.comp (DSmooth.prod_mk ?_ dsmooth_const)
    exact (EuclideanSpace.proj (ùïú := ‚Ñù) (0 : Fin 1)).dsmooth
  map_add' v w := by
    let i‚ÇÅ : Eucl 1 ‚ÜíL[‚Ñù] Eucl 2 := ‚ü®‚ü®‚ü®fun t ‚Ü¶ .single (0 : Fin 2) (t 0), fun _ _ ‚Ü¶
      Pi.single_add _ _ _‚ü©, fun a _ ‚Ü¶ Pi.single_smul _ a _‚ü©, (LinearMap.dsmooth _ _).continuous‚ü©
    let i‚ÇÇ : Eucl 1 ‚ÜíL[‚Ñù] Eucl 2 := ‚ü®‚ü®‚ü®fun t ‚Ü¶ .single (1 : Fin 2) (t 0), fun _ _ ‚Ü¶
      Pi.single_add _ _ _‚ü©, fun a _ ‚Ü¶ Pi.single_smul _ a _‚ü©, (LinearMap.dsmooth _ _).continuous‚ü©
    let p : pointedPlots x := ‚ü®‚ü®2, fun t ‚Ü¶ x + t 0 ‚Ä¢ v + t 1 ‚Ä¢ w‚ü©, by
      -- TODO get fun_prop to handle this
      simp_rw [add_assoc]
      refine ((dsmooth_add_left x).comp (DSmooth.add ?_ ?_)).isPlot <;>
        refine dsmooth_smul.comp (DSmooth.prod_mk ?_ dsmooth_const) <;>
        exact (EuclideanSpace.proj (ùïú := ‚Ñù) (_ : Fin 2)).dsmooth, by simp‚ü©
    have h‚ÇÅ := InternalTangentSpace.lof_comp_apply p i‚ÇÅ.contDiff (map_zero i‚ÇÅ) (.single 0 1)
    have h‚ÇÇ := InternalTangentSpace.lof_comp_apply p i‚ÇÇ.contDiff (map_zero i‚ÇÇ) (.single 0 1)
    have h‚ÇÉ := InternalTangentSpace.lof_comp_apply p (i‚ÇÅ + i‚ÇÇ).contDiff (by simp) (.single 0 1)
    refine .trans (by congr; ext; simp [p, i‚ÇÅ, i‚ÇÇ, add_assoc]) <| h‚ÇÉ.trans ?_
    simp only [Function.comp_apply, ContinuousLinearMap.fderiv, ContinuousLinearMap.add_apply,
      map_add, p] at h‚ÇÅ h‚ÇÇ ‚ä¢
    refine (((add_left_inj _).2 h‚ÇÅ).trans ((add_right_inj _).2 h‚ÇÇ)).symm.trans ?_
    congr <;> ext <;> simp [i‚ÇÅ, i‚ÇÇ]
  map_smul' a v := by
    let f : Eucl 1 ‚ÜíL[‚Ñù] Eucl 1 := ‚ü®‚ü®‚ü®fun t ‚Ü¶ a ‚Ä¢ t, by simp‚ü©,
      by simp [smul_smul, mul_comm a]‚ü©, (LinearMap.dsmooth _ _).continuous‚ü©
    let p : pointedPlots x := ‚ü®‚ü®1, fun t ‚Ü¶ x + (t 0) ‚Ä¢ v‚ü©, by
      -- TODO get fun_prop to handle this
      refine ((dsmooth_add_left x).comp ?_).isPlot
      refine dsmooth_smul.comp (DSmooth.prod_mk ?_ dsmooth_const)
      exact (EuclideanSpace.proj (ùïú := ‚Ñù) (0 : Fin 1)).dsmooth, by simp‚ü©
    have h := InternalTangentSpace.lof_comp_apply p f.contDiff (map_zero f) (.single 0 1)
    rw [f.fderiv] at h; rw [‚Üê map_smul]
    convert h; dsimp [p, f]; rw [smul_smul, mul_comm a]

/-- The canonical map from a fine diffeological vector space to its internal tangent space at a
point is injective.

Note that this isn't the case for arbitrary diffeological vector spaces, because e.g. any vector
space becomes a diffeological vector space with the coarse diffeology but internal tangent spaces
of coarse spaces are all trivial. -/
lemma vectorSpaceToInternalTangentSpace_injective [AddCommGroup X] [Module ‚Ñù X]
    [IsFineDiffeology ‚Ñù X] {x : X} : Function.Injective (vectorSpaceToInternalTangentSpace x) := by
  intro v w h; unfold vectorSpaceToInternalTangentSpace at h
  simp at h
  sorry

/-- The canonical map from a fine diffeological vector space to its internal tangent space at a
point is surjective.

I don't yet know whether this holds more generally for all diffeological vector spaces, but
wouldn't bet on it. -/
lemma vectorSpaceToInternalTangentSpace_surjective [AddCommGroup X] [Module ‚Ñù X]
    [IsFineDiffeology ‚Ñù X] {x : X} : Function.Surjective (vectorSpaceToInternalTangentSpace x) := by
  intro v; unfold vectorSpaceToInternalTangentSpace
  simp
  sorry

/-- The canonical isomorphism between the internal tangent space of a fine diffeological vector
space and the vector space itself, given in the backwards direction by
`vectorSpaceToInternalTangentSpace`. -/
def InternalTangentSpaceVectorSpaceEquivSelf [AddCommGroup X] [Module ‚Ñù X] [IsFineDiffeology ‚Ñù X]
    (x : X) : InternalTangentSpace x ‚âÉ‚Çó[‚Ñù] X :=
  (LinearEquiv.ofBijective _ ‚ü®vectorSpaceToInternalTangentSpace_injective,
    vectorSpaceToInternalTangentSpace_surjective‚ü©).symm
