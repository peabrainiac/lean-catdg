import Orbifolds.Diffeology.DDiffeomorph

universe u v

open DirectSum DiffeologicalSpace Classical

noncomputable section

variable {X Y : Type u} [DiffeologicalSpace X] [DiffeologicalSpace Y]

/-- The set of all plots in `X` that send `0` to `x`. -/
def DiffeologicalSpace.pointedPlots (x : X) : Set ((n : ℕ) × (Eucl n → X)) :=
  {p | IsPlot p.2 ∧ p.2 0 = x}

/-- The direct sum of the domains of all pointed plots to `x`.
  The actual internal tangent space is obtained as a quotient from this. -/
def preInternalTangentSpace (x : X) := ⨁ p : pointedPlots x, Eucl p.1.1

instance {x : X} : AddCommGroup (preInternalTangentSpace x) := by
  unfold preInternalTangentSpace; infer_instance

instance {x : X} : Module ℝ (preInternalTangentSpace x) := by
  unfold preInternalTangentSpace; infer_instance

/-- The internal tangent space of `X` at `x`, implemented here as the quotient of
  `preInternalTangentSpace x` by the subspace generated by some relations. -/
def internalTangentSpace (x : X) := preInternalTangentSpace x ⧸ Submodule.span ℝ
  {v : preInternalTangentSpace x | ∃ p q : pointedPlots x,
    ∃ f : DSmoothMap (Eucl p.1.1) (Eucl q.1.1), ∃ w : Eucl p.1.1,
      v = DirectSum.of _ p w - DirectSum.of _ q (fderiv ℝ f 0 w)}

instance {x : X} : AddCommGroup (internalTangentSpace x) := by
  unfold internalTangentSpace; infer_instance

instance {x : X} : Module ℝ (internalTangentSpace x) := by
  unfold internalTangentSpace; infer_instance

/-- Transports plots from `x` to `f x` for any smooth map `f`. -/
def DiffeologicalSpace.pointedPlots_map {f : X → Y} (hf : DSmooth f) (x : X) :
    pointedPlots x → pointedPlots (f x) :=
  fun p ↦ ⟨⟨p.1.1, f ∘ p.1.2⟩, (hf.comp p.2.1.dsmooth).isPlot, by simp [p.2.2]⟩

/-- The map `preInternalTangentSpace x →ₗ[ℝ] preInternalTangentSpace (f x)` that
  descents to the actual tangent map. Defined as `0` when `f` isn't smooth. -/
def preInternalTangentMap (f : X → Y) (x : X) :
    preInternalTangentSpace x →ₗ[ℝ] preInternalTangentSpace (f x) :=
  if hf : DSmooth f then
    DirectSum.toModule _ _ _ fun p ↦ (DirectSum.lof _ _ _ <|
      DiffeologicalSpace.pointedPlots_map hf x p : _ →ₗ[ℝ] preInternalTangentSpace (f x))
  else 0

/-- The internal tangent map of `f` at `x` when `f` is smooth, and `0` otherwise. -/
def internalTangentMap (f : X → Y) (x : X) :
    internalTangentSpace x →ₗ[ℝ] internalTangentSpace (f x) :=
  Submodule.mapQ _ _ (preInternalTangentMap f x) (by
    by_cases hf : DSmooth f
    · rw [← Submodule.map_le_iff_le_comap, Submodule.map_span_le]
      intro v ⟨p, q, g, w, hv⟩
      apply Submodule.subset_span
      use DiffeologicalSpace.pointedPlots_map hf x p
      use DiffeologicalSpace.pointedPlots_map hf x q
      use g
      use w
      --simp [preInternalTangentMap, hf, hv, pointedPlots_map]
      sorry
    · sorry)
