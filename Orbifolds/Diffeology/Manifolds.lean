import Orbifolds.Diffeology.LocallyModelled
import Mathlib.Geometry.Manifold.Instances.Real
import Mathlib.Geometry.Manifold.InteriorBoundary
import Mathlib.Geometry.Manifold.ContMDiff.NormedSpace
import Mathlib.Geometry.Manifold.ContMDiff.Atlas
import Mathlib.Geometry.Manifold.SmoothManifoldWithCorners

/-!
# Diffeological manifolds
Some lemmas and theorems on manifolds as diffeological spaces, as defined in
`Orbifolds.Diffeology.LocallyModelled`. The main purpose of this file is to show how this
relates to the notion of smooth manifolds defined in mathlib , i.e. that those are indeed
equivalent.
-/

open Set

open scoped Manifold

open PartialHomeomorph in
/-- The diffeology defined by a manifold structure on M, with the plots given by the maps
  that are smooth in the sense of mathlib's `ContMDiff`-API.
  This can not be an instance because `SmoothManifoldWithCorners I M` depends on `I` while
  `DiffeologicalSpace M` does not, and because it would probably lead to instance diamonds on
  things like products even if some workaround was found. -/
def SmoothManifoldWithCorners.toDiffeology {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) (M : Type*)
    [TopologicalSpace M] [ChartedSpace H M] [SmoothManifoldWithCorners I M] :
    DiffeologicalSpace M :=
  DiffeologicalSpace.mkOfPlotsOn {
    isPlotOn := fun {n u} _ p ‚Ü¶ ContMDiffOn (ùì° n) I ‚ä§ p u
    isPlotOn_congr := fun _ _ _ h ‚Ü¶ contMDiffOn_congr h
    isPlot := fun {n} p ‚Ü¶ ContMDiff (ùì° n) I ‚ä§ p
    isPlotOn_univ := contMDiffOn_univ
    isPlot_const := fun _ ‚Ü¶ contMDiff_const
    isPlotOn_reparam := fun _ _ _ h hp hf ‚Ü¶ hp.comp hf.contMDiffOn h.subset_preimage
    locality := fun _ _ h ‚Ü¶ fun x hxu ‚Ü¶ by
      let ‚ü®v,hv,hxv,hv'‚ü© := h x hxu
      exact ((hv' x hxv).contMDiffAt (hv.mem_nhds hxv)).contMDiffWithinAt
  }

/-- The plots of a manifold are by definition precisely the smooth maps. -/
lemma isPlot_iff_smooth {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) (M : Type*)
    [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    {n : ‚Ñï} {p : Eucl n ‚Üí M} : IsPlot[m.toDiffeology] p ‚Üî ContMDiff (ùì° n) I ‚ä§ p := Iff.rfl

lemma SmoothManifoldWithCorners.toDiffeology_eq_euclideanDiffeology {E : Type*}
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] :
    (model_space_smooth (I := ùìò(‚Ñù,E))).toDiffeology = euclideanDiffeology := by
  ext n p; exact contMDiff_iff_contDiff

def ModelWithCorners.toHomeomorphTarget {ùïú : Type*} [NontriviallyNormedField ùïú] {E : Type*}
    [NormedAddCommGroup E] [NormedSpace ùïú E] {H : Type*} [TopologicalSpace H]
    (I : ModelWithCorners ùïú E H) : H ‚âÉ‚Çú I.target where
  toFun x := ‚ü®I x,I.map_source (I.source_eq ‚ñ∏ mem_univ x)‚ü©
  invFun y := I.invFun y
  left_inv := I.left_inv
  right_inv := fun _ => Subtype.ext <| I.right_inv _

/-- The D-topology on a manifold is always at least as fine as the usual topology. -/
lemma SmoothManifoldWithCorners.dTop_le {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
    (M : Type*) [tM : TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M] :
    DTop[m.toDiffeology] ‚â§ tM :=
  TopologicalSpace.le_def.2 fun _ hu _ _ hp => IsOpen.preimage (hp.continuous) hu

/-- If the subspace topology and D-topology agree on the set `H` that the manifold is modelled on,
  the topology of the manifold agrees with the D-topology as well.-/
instance {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E]
    {H : Type*} [tH : TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
    [@DTopCompatible I.target _ <| @instDiffeologicalSpaceSubtype _ euclideanDiffeology _]
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M] :
    let _ := m.toDiffeology; DTopCompatible M := let _ := m.toDiffeology; ‚ü®by
  let dE := euclideanDiffeology (X := E); let dH := dE.induced I
  have : DTopCompatible H := ‚ü®by
    dsimp [dH]; rw [show ‚ÜëI = (‚Üë) ‚àò I.toHomeomorphTarget by rfl,‚ÜêdE.induced_compose,
      dTop_induced_comm (by convert isOpen_univ; exact Equiv.range_eq_univ _),dTop_eq _,
      Homeomorph.induced_eq]‚ü©
  ext u; refine' ‚ü®fun h => _,fun hu n p hp => IsOpen.preimage (hp.continuous) hu‚ü©
  refine' isOpen_iff_mem_nhds.2 fun x hxu => mem_nhds_iff.2
    ‚ü®_,inter_subset_right,_,mem_chart_source H x,hxu‚ü©
  have _ := (chartAt H x).open_target.dTopCompatible
  refine' Subtype.image_preimage_val _ _ ‚ñ∏ (chartAt H x).open_source.isOpenMap_subtype_val _ _
  rw [‚Üê(chartAt H x).toHomeomorphSourceTarget.symm.isOpen_preimage]
  simp_rw [‚ÜêdTop_eq (chartAt H x).target]; rw [isOpen_iff_preimages_plots]; intro n p hp
  simp_rw [‚Üêpreimage_comp,Function.comp_assoc]
  rw [isOpen_iff_preimages_plots] at h; refine' h n _ _; rw [isPlot_iff_smooth]
  replace hp := (isPlot_induced_iff.1 <| isPlot_induced_iff.1 hp).contMDiff
  replace hp := (contMDiffOn_model_symm).comp_contMDiff hp fun x => mem_range_self _
  rw [‚ÜêFunction.comp_assoc,I.symm_comp_self,Function.id_comp] at hp
  exact (contMDiffOn_chart_symm (x := x)).comp_contMDiff hp fun x => (p x).2‚ü©

/-- In particular, the D-topology agrees with the standard topology on all manifolds
  modelled on a "boundaryless" model.
  TODO: It would be nice to have this (and all lemmas depending on it) for all boundaryless
  manifolds in the sense of `BoundarylessManifold`, such as manifolds with corners whose
  boundary just happens to be empty, but that would require either redoing the above lemma
  in slightly greater generality or passing from manifolds with empty boundary to manifolds
  modelled on a boundaryless model, both of which sound like a lot of work for something that
  is not a high priority. -/
instance {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E]
    {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) [hI : I.Boundaryless]
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M] :
    let _ := m.toDiffeology; DTopCompatible M := by
  let _ := m.toDiffeology; let _ := euclideanDiffeology (X := E)
  have : DTopCompatible I.target :=
    I.target_eq.trans hI.range_eq_univ ‚ñ∏ isOpen_univ.dTopCompatible
  infer_instance

/-- Every smooth map between manifolds is also D-smooth, i.e. this construction defines a
  functor of concrete categories. -/
theorem ContMDiff.dsmooth {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {H : Type*} [TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type*}
    [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
    {H' : Type*} [TopologicalSpace H'] {I' : ModelWithCorners ‚Ñù E' H'} {N : Type*}
    [TopologicalSpace N] [ChartedSpace H' N] [m' : SmoothManifoldWithCorners I' N]
    {f : M ‚Üí N} (hf : ContMDiff I I' ‚ä§ f) : DSmooth[m.toDiffeology,m'.toDiffeology] f :=
  fun _ _ => hf.comp

/-- Every map between manifolds that is smooth on a subset is also smooth diffeologically
  with respect to the subspace diffeology. -/
theorem ContMDiffOn.dsmooth_restrict {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    {H : Type*} [TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type*}
    [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
    {H' : Type*} [TopologicalSpace H'] {I' : ModelWithCorners ‚Ñù E' H'} {N : Type*}
    [TopologicalSpace N] [ChartedSpace H' N] [m' : SmoothManifoldWithCorners I' N]
    {f : M ‚Üí N} {s : Set M} (hf : ContMDiffOn I I' ‚ä§ f s) :
    let _ := m.toDiffeology; let _ := m'.toDiffeology; DSmooth (s.restrict f) := by
  let _ := m.toDiffeology; let _ := m'.toDiffeology
  refine' fun n p hp => _
  rw [restrict_eq,Function.comp_assoc]
  exact hf.comp_contMDiff hp fun x => (p x).2

open PartialHomeomorph in
/-- Every D-smooth map from a boundaryless manifold to another manifold is also smooth.
  This could probably be proven in quite a lot greater generality. -/
theorem IsOpen.dsmooth_iff_smoothOn {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {H : Type*} [TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H}
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    [hI : I.Boundaryless]
    {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E'] [FiniteDimensional ‚Ñù E']
    {H' : Type*} [TopologicalSpace H'] {I' : ModelWithCorners ‚Ñù E' H'} (N : Type*)
    [TopologicalSpace N] [ChartedSpace H' N] [m' : SmoothManifoldWithCorners I' N]
    {f : M ‚Üí N} {s : Set M} (hs : IsOpen s) : let _ := m.toDiffeology;
    let _ := m'.toDiffeology; DSmooth (s.restrict f) ‚Üî ContMDiffOn I I' ‚ä§ f s := by
  let _ := m.toDiffeology; let _ := m'.toDiffeology
  refine' ‚ü®fun hf x hxs => _,ContMDiffOn.dsmooth_restrict‚ü©
  -- TODO
  sorry

open PartialHomeomorph in
/-- Every D-smooth map from a boundaryless manifold to another manifold is also smooth.
  This could probably be proven in quite a lot greater generality. -/
theorem DSmooth.smooth {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E]
    {H : Type*} [TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type*}
    [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    [hI : I.Boundaryless]
    {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E'] [FiniteDimensional ‚Ñù E']
    {H' : Type*} [TopologicalSpace H'] {I' : ModelWithCorners ‚Ñù E' H'} {N : Type*}
    [TopologicalSpace N] [ChartedSpace H' N] [m' : SmoothManifoldWithCorners I' N]
    {f : M ‚Üí N} (hf : DSmooth[m.toDiffeology,m'.toDiffeology] f) : ContMDiff I I' ‚ä§ f := by
  let _ := m.toDiffeology; let _ := m'.toDiffeology
  intro x; let x' := toEuclidean (extChartAt I x x); let n := Module.finrank ‚Ñù E
  let ‚ü®Œµ,hŒµ,hŒµ'‚ü© := Metric.isOpen_iff.1 (toEuclidean.isOpenMap _ (isOpen_extChartAt_target x))
    x' <| mem_image_of_mem _ <| (extChartAt I x).map_source (mem_extChartAt_source x)
  let e := (extChartAt I x).symm ‚àò toEuclidean.symm ‚àò
    (univUnitBall.trans' (unitBallBall x' Œµ hŒµ) rfl)
  have he : ContMDiff (ùì° n) I ‚ä§ e := (contMDiffOn_extChartAt_symm x).comp_contMDiff
    (toEuclidean.symm.contDiff.comp <| (contDiff_unitBallBall hŒµ).comp
    contDiff_univUnitBall).contMDiff fun x'' => (mem_image_equiv (f := toEuclidean.toEquiv)).1 <|
    hŒµ' <| (univUnitBall.trans' (unitBallBall x' Œµ hŒµ) rfl).map_source <| mem_univ _
  let e' := (univUnitBall.trans' (unitBallBall x' Œµ hŒµ) rfl).symm ‚àò toEuclidean ‚àò extChartAt I x
  have he' : ContMDiffOn I (ùì° n) ‚ä§ e' _ :=
    (contDiffOn_univUnitBall_symm.comp (contDiff_unitBallBall_symm hŒµ).contDiffOn fun _ hx'' =>
        mem_preimage.2 ((unitBallBall x' Œµ hŒµ).symm.map_source hx'')).contMDiffOn.comp
      (toEuclidean.contDiff.contMDiff.comp_contMDiffOn <| contMDiffOn_extChartAt.mono <|
        inter_subset_right) inter_subset_left
  refine' (((hf n _ he).comp_contMDiffOn he').congr (fun x'' hx'' => _) x _).contMDiffAt _
  ¬∑ simp_rw [e,e',Function.comp_apply]
    rw [(univUnitBall.trans' (unitBallBall x' Œµ hŒµ) rfl).right_inv (by exact hx''.1),
      toEuclidean.symm_apply_apply,(extChartAt I x).left_inv (extChartAt_source I x ‚ñ∏ hx''.2)]
  ¬∑ exact ‚ü®Metric.mem_ball_self hŒµ,mem_chart_source H x‚ü©
  ¬∑ refine' IsOpen.mem_nhds _ ‚ü®Metric.mem_ball_self hŒµ,mem_chart_source H x‚ü©
    exact inter_comm _ _ ‚ñ∏ extChartAt_source I x ‚ñ∏ ContinuousOn.isOpen_inter_preimage
      (toEuclidean.continuous.comp_continuousOn (continuousOn_extChartAt x))
      (isOpen_extChartAt_source x) Metric.isOpen_ball

/-- A finite-dimensional, boundaryless `SmoothManifoldWithCorners` is also a manifold in the
  diffeological sense of `IsManifold`. -/
theorem SmoothManifoldWithCorners.isManifold {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [m : SmoothManifoldWithCorners I M]
    [hI : I.Boundaryless] : @IsManifold (Module.finrank ‚Ñù E) M m.toDiffeology :=
  let _ := m.toDiffeology; let _ := euclideanDiffeology (X := E)
  ‚ü®fun x => (dTop_eq M).symm ‚ñ∏ ‚ü®_,isOpen_extChartAt_source x,mem_extChartAt_source x,
    (),_,toEuclidean.isOpenMap _ (isOpen_extChartAt_target x),‚ü®{
      toEquiv := ((extChartAt I x).trans' (toEuclidean.toEquiv.toPartialEquivOfImageEq
        (extChartAt I x).target _ rfl) rfl).toEquiv
      dsmooth_toFun := by
        dsimp [PartialEquiv.trans',PartialEquiv.toEquiv,-extChartAt]
        refine' (toEuclidean.contDiff.dsmooth.comp _).subtype_mk _
        exact (toDiffeology_eq_euclideanDiffeology (E := E) ‚ñ∏ (extChartAt_source I x).symm ‚ñ∏
          (contMDiffOn_extChartAt (I := I) (x := x)).dsmooth_restrict:)
      dsmooth_invFun := by
        dsimp [PartialEquiv.trans',PartialEquiv.toEquiv,-extChartAt]
        refine' DSmooth.subtype_mk _ _
        rw [‚ÜêFunction.comp_def (extChartAt I x).symm,‚ÜêFunction.comp_def _ Subtype.val,
          ‚Üê(mapsTo_image _ _).restrict_commutes _ _ _,‚ÜêFunction.comp_assoc]
        refine' DSmooth.comp _ (toEuclidean.symm.contDiff.dsmooth.restrict _)
        exact (toEuclidean.symm_image_image (extChartAt I x).target).symm ‚ñ∏
          (toDiffeology_eq_euclideanDiffeology (E := E) ‚ñ∏
            (contMDiffOn_extChartAt_symm (I := I) x).dsmooth_restrict:)
    }‚ü©‚ü©‚ü©

-- TODO: move this and related lemmas to a more fitting place
open Classical in
@[simps]
noncomputable def PartialEquiv.fromEquivSourceTarget {Œ± Œ≤ : Type*} {s : Set Œ±} {t : Set Œ≤}
    (e : s ‚âÉ t) (a : s) : PartialEquiv Œ± Œ≤ where
  toFun := fun x => if hx : x ‚àà s then e ‚ü®x,hx‚ü© else e a
  invFun := fun y => if hy : y ‚àà t then e.symm ‚ü®y,hy‚ü© else a
  source := s
  target := t
  map_source' := fun _ hx => by simp [hx]
  map_target' := fun _ hy => by simp [hy]
  left_inv' := fun _ hx => by simp [hx]
  right_inv' := fun _ hy => by simp [hy]

@[simp]
lemma PartialEquiv.fromEquivSourceTarget_restrict {Œ± Œ≤ : Type*} {s : Set Œ±} {t : Set Œ≤}
    (e : s ‚âÉ t) (a : s) : s.restrict (fromEquivSourceTarget e a) = (‚Üë) ‚àò e := by
  ext x; simp

@[simp]
lemma PartialEquiv.fromEquivSourceTarget_symm_restrict {Œ± Œ≤ : Type*} {s : Set Œ±} {t : Set Œ≤}
    (e : s ‚âÉ t) (a : s) : t.restrict (fromEquivSourceTarget e a).symm = (‚Üë) ‚àò e.symm := by
  ext x; simp

@[simp]
lemma PartialEquiv.fromEquivSourceTarget_toEquiv {Œ± Œ≤ : Type*} {s : Set Œ±} {t : Set Œ≤}
    (e : s ‚âÉ t) (a : s) : (fromEquivSourceTarget e a).toEquiv = e := by
  ext x; simp only [PartialEquiv.toEquiv,fromEquivSourceTarget_apply,fromEquivSourceTarget_source,
    Subtype.coe_prop]; rfl

@[simps!]
noncomputable def PartialHomeomorph.fromHomeomorphSourceTarget {Œ± Œ≤ : Type*} [TopologicalSpace Œ±]
    [TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤} (e : s ‚âÉ‚Çú t) (hs : IsOpen s) (ht : IsOpen t)
    (a : s) : PartialHomeomorph Œ± Œ≤ where
  toPartialEquiv := PartialEquiv.fromEquivSourceTarget e.toEquiv a
  open_source := hs
  open_target := ht
  continuousOn_toFun := by simp [continuousOn_iff_continuous_restrict,continuous_subtype_val]
  continuousOn_invFun := by simp [continuousOn_iff_continuous_restrict,continuous_subtype_val]

@[simp]
lemma PartialHomeomorph.fromHomeomorphSourceTarget_toPartialEquiv {Œ± Œ≤ : Type*}
    [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤} (e : s ‚âÉ‚Çú t) (hs : IsOpen s)
    (ht : IsOpen t) (a : s) : (fromHomeomorphSourceTarget e hs ht a).toPartialEquiv =
    PartialEquiv.fromEquivSourceTarget e.toEquiv a := rfl

/-- Charted space structure of a diffeological manifold, consisting of all local diffeomorphisms
  between `M` and `Eucl n`. -/
noncomputable def IsManifold.toChartedSpace {M : Type*} [DiffeologicalSpace M] {n : ‚Ñï}
    [hM : IsManifold n M] : @ChartedSpace (Eucl n) _ M DTop := by
  let _ := @DTop M _; let _ : DTopCompatible M := ‚ü®rfl‚ü©; exact {
    atlas := {e | DSmooth e.toEquiv ‚àß DSmooth e.toEquiv.symm}
    chartAt := fun x => by
      have h := hM.locally_modelled x
      have hu := h.choose_spec.1; have hxu := h.choose_spec.2.1
      have hv := h.choose_spec.2.2.choose_spec.choose_spec.1
      have _ := hu.dTopCompatible; have _ := hv.dTopCompatible
      exact PartialHomeomorph.fromHomeomorphSourceTarget
        (h.choose_spec.2.2.choose_spec.choose_spec.2.some.toHomeomorph') hu hv ‚ü®x,hxu‚ü©
    mem_chart_source := fun x => by exact (hM.locally_modelled x).choose_spec.2.1
    chart_mem_atlas := fun x => by
      let e := (hM.locally_modelled x).choose_spec.2.2.choose_spec.choose_spec.2.some
      dsimp; rw [PartialEquiv.fromEquivSourceTarget_toEquiv]
      exact ‚ü®e.dsmooth,e.symm.dsmooth‚ü©
  }
