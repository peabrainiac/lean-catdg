import Mathlib.CategoryTheory.Sites.Coverage
--import Mathlib.CategoryTheory.Sites.Sheaf
import Orbifolds.Diffeology.DiffSp

/-!
# CartSp

This file defines `CartSp` as the category of cartesian spaces and smooth maps, equipped with
the open cover coverage. This makes it into a site, on which concrete sheaves correspond
directly to diffeological spaces.

See https://ncatlab.org/nlab/show/CartSp.

Note however that with the current implementation, this could not be used to *define*
diffeological spaces - it already uses diffeology in the definition of
`CartSp.openCoverCoverage`. The reason is that smooth embeddings are apparently not yet
implemented in mathlib, so diffeological inductions are used instead.

Main definitions / results:
* `CartSp`: the category of euclidean spaces and smooth maps between them
* `CartSp.openCoverCoverage`: the coverage given by jointly surjective open inductions
* `SmoothSp`: the category of smooth sets, as the category of sheaves on `CartSp`
* `DiffSp.toSmoothSp`: the embedding of diffeological spaces into smooth sets
-/

universe u

open CategoryTheory Sheaf

def CartSp := ‚Ñï

instance : CoeSort CartSp Type where
  coe n := EuclideanSpace ‚Ñù (Fin n)

instance (n : ‚Ñï) : OfNat CartSp n where
  ofNat := n

instance : SmallCategory CartSp where
  Hom := fun n m => DSmoothMap n m
  id := fun n => DSmoothMap.id
  comp := fun f g => ‚ü®_,g.2.comp f.2‚ü©

instance : ConcreteCategory CartSp where
  forget := { obj := fun n => n, map := fun f => f.1 }
  forget_faithful := { map_injective := fun {_ _} => Subtype.coe_injective }

instance instFunLike (n m : CartSp) : FunLike (n ‚ü∂ m) n m where
  coe := Subtype.val
  coe_injective' := Subtype.coe_injective

@[simp]
theorem id_app (n : CartSp) (x : n) : (ùüô n : n ‚ü∂ n) x = x := rfl

@[simp]
theorem comp_app {n m k : CartSp} (f : n ‚ü∂ m) (g : m ‚ü∂ k) (x : n) :
    (f ‚â´ g : n ‚Üí k) x = g (f x) := rfl

/-- The open cover coverage on `CartSp`, consisting of all coverings by open smooth embeddings.
  Since mathlib apparently doesn't have smooth embeddings yet, diffeological inductions are
  used instead. -/
def CartSp.openCoverCoverage : Coverage CartSp where
  covering n := {s | (‚àÄ (m : _) (f : m ‚ü∂ n), s f ‚Üí Induction f.1 ‚àß IsOpenMap f.1) ‚àß
    ‚ãÉ (m : CartSp) (f ‚àà s (Y := m)), Set.range f.1 = Set.univ}
  pullback n m g s hs := by
    use fun k => {f | (‚àÉ (k : _) (f' : k ‚ü∂ n), s f' ‚àß Set.range (g.1 ‚àò f.1) ‚äÜ Set.range f'.1)
      ‚àß Induction f.1 ‚àß IsOpenMap f.1}
    refine ‚ü®‚ü®fun k f hf => hf.2, ?_‚ü©, ?_‚ü©
    ¬∑ refine Set.iUnion_eq_univ_iff.2 fun x => ?_
      let ‚ü®k,hk‚ü© := Set.iUnion_eq_univ_iff.1 hs.2 (g x)
      let ‚ü®f,hf,hgx‚ü© := Set.mem_iUnion‚ÇÇ.1 hk
      refine ‚ü®m, Set.mem_iUnion‚ÇÇ.2 ?_‚ü©
      let ‚ü®Œµ, hŒµ, hxŒµ‚ü© := Metric.isOpen_iff.1
        ((hs.1 k f hf).2.isOpen_range.preimage g.2.continuous) x hgx
      let e := (DDiffeomorph.univBall x hŒµ)
      use ‚ü®_, dsmooth_subtype_val.comp e.dsmooth‚ü©
      refine ‚ü®‚ü®?_, ?_‚ü©, ?_‚ü©
      ¬∑ refine ‚ü®k, f, hf, subset_trans ?_ (Set.image_subset_iff.2 hxŒµ)‚ü©
        simp_rw [Set.range_comp]; apply Set.image_mono; simp
      ¬∑ refine ‚ü®induction_subtype_val.comp e.induction, ?_‚ü©
        have := (Metric.isOpen_ball  (x := x) (Œµ := Œµ)).dTopCompatible
        exact (Metric.isOpen_ball).isOpenMap_subtype_val.comp e.toHomeomorph'.isOpenMap
      ¬∑ change x ‚àà Set.range (Subtype.val ‚àò e.toEquiv)
        rw [e.surjective.range_comp]; simp [hŒµ]
    ¬∑ intro k f ‚ü®‚ü®k',f',hf'‚ü©,_‚ü©; use k'
      let f'' := (DDiffeomorph.ofInduction (hs.1 k' f' hf'.1).1)
      use ‚ü®_,(f''.dsmooth_invFun.comp <|
        (f ‚â´ g).2.subtype_mk (fun x => hf'.2 (Set.mem_range_self x)))‚ü©
      refine ‚ü®f', hf'.1, ?_‚ü©; ext x; change f'.1 (f''.invFun _) = _
      simp_rw [show f'.1 = Subtype.val ‚àò f'' by rfl]
      dsimp; rw [DDiffeomorph.apply_symm_apply,comp_apply]; rfl

/-- The open cover grothendieck topology on `CartSp`. -/
def CartSp.openCoverTopology : GrothendieckTopology CartSp :=
  openCoverCoverage.toGrothendieck

/-- The category of sheaves on `CartSp`, also known as *smooth spaces*. -/
def SmoothSp := SheafOfTypes CartSp.openCoverTopology

/-- This *should* be an instance already, but somehow could not be inferred.
  It doesn't make sense to me, but this seems to work for now. -/
instance : Category.{u,u+1} SmoothSp.{u} := SheafOfTypes.instCategory

/-- The embedding of diffeological spaces into smooth spaces. -/
def DiffSp.toSmoothSp : DiffSp.{u} ‚•§ SmoothSp.{u} where
  obj X := ‚ü®{
    obj := fun n => DSmoothMap n.unop X
    map := fun f g => g.comp f.unop
    map_id := fun _ => rfl
    map_comp := fun _ _ => rfl
  }, by
    rw [CartSp.openCoverTopology, Presieve.isSheaf_coverage]
    refine fun {n} s hs f hf => ?_
    have hs' : ‚àÄ x : n, _ := fun x => Set.mem_iUnion.1 <| hs.2.symm ‚ñ∏ Set.mem_univ x
    let k := fun x => (hs' x).choose
    have hk : ‚àÄ x, ‚àÉ f' : k x ‚ü∂ n, _ := fun x => Set.mem_iUnion‚ÇÇ.1 (hs' x).choose_spec
    let f' := fun x => (hk x).choose
    have hf' : ‚àÄ x, s (f' x) ‚àß x ‚àà Set.range (f' x).1 :=
      fun x => exists_prop.1 (hk x).choose_spec
    let f'' := fun x => f (f' x) (hf' x).1 (hf' x).2.choose
    have hf'' : ‚àÄ l (g : l ‚ü∂ n) (hg : s g), f'' ‚àò g = f g hg := fun l g hg => by
      ext x
      dsimp [f'']
      have h := @hf _ _ 0 (DSmoothMap.const (hf' (g x)).2.choose)
        (DSmoothMap.const x) _ _ (hf' (g x)).1 hg
        (by ext; exact (hf' (g x)).2.choose_spec)
      exact DFunLike.congr_fun h 0
    refine ‚ü®‚ü®f'', ?_‚ü©, ?_, ?_‚ü©
    ¬∑ refine dsmooth_iff_locally_dsmooth.2 fun x : n =>
        ‚ü®_, (hs.1 _ _ (hf' x).1).2.isOpen_range, (hf' x).2, ?_‚ü©
      rw [(DDiffeomorph.ofInduction (hs.1 _ _ (hf' x).1).1).subduction.dsmooth_iff]
      convert (f (f' x) (hf' x).1).2; exact hf'' (k x) (f' x) (hf' x).1
    ¬∑ intro l g hg; ext x; exact congr_fun (hf'' l g hg) _
    ¬∑ intro f''' hf'''; ext (x : n)
      rw [‚Üê (hf' x).2.choose_spec]
      exact (DFunLike.congr_fun (hf''' (f' x) (hf' x).1) _).trans
        (congr_fun (hf'' _ (f' x) (hf' x).1) _).symm‚ü©
  map f := ‚ü®{
    app := fun _ g => f.comp g
    naturality := fun _ _ _ => rfl
  }‚ü©
  map_id := fun _ => rfl
  map_comp := fun _ _ => rfl
