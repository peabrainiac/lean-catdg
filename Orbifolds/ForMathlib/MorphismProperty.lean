import Mathlib.CategoryTheory.Sites.MorphismProperty

/-!
# Results on morphism properties
Results on morphism properties that should go into `Mathlib.CategoryTheory.Sites.MorphismProperty`
or earlier files.
-/

namespace CategoryTheory.MorphismProperty

open Limits

variable {C : Type*} [Category C]

/-- The presieve on `X` consisting of all morphisms to `X` that satisfy the property `P`. -/
protected def toPresieveOn (P : MorphismProperty C) (X : C) : Presieve X :=
  fun _ f ‚Ü¶ P f

/-- The sieve on `X` that is generated by `P.toPresieve X`, consisting of all morphisms that factor
through a morphism satisfying `P`. -/
@[simps!]
protected def toSieveOn (P : MorphismProperty C) (X : C) : Sieve X :=
  .generate (P.toPresieveOn X)

lemma toSieveOn_arrows_eq_toPresieveOn {P : MorphismProperty C} [P.RespectsLeft ‚ä§] {X : C} :
    (P.toSieveOn X).arrows = P.toPresieveOn X := by
  refine (Sieve.le_generate _).antisymm' ?_
  intro Y f ‚ü®Z, h, g, hg, hf‚ü©
  exact hf ‚ñ∏ RespectsLeft.precomp (Q := ‚ä§) h trivial g hg

lemma toPresieveOn_le_iff {P : MorphismProperty C} {X : C} (S : Presieve X) :
    P.toPresieveOn X ‚â§ S ‚Üî ‚àÄ (Y : C) (f : Y ‚ü∂ X), P f ‚Üí S f :=
  .rfl

lemma toSieveOn_le_iff {P : MorphismProperty C} {X : C} (S : Sieve X) :
    P.toSieveOn X ‚â§ S ‚Üî ‚àÄ (Y : C) (f : Y ‚ü∂ X), P f ‚Üí S f :=
  Sieve.generate_le_iff _ _

/-- Typeclass asserting that every morphism in `P` can be factored as a morphism in `Q` followed by
a morphism in `Q'`. -/
class HasFactorizationInto (P Q Q' : MorphismProperty C) : Prop where
  nonempty_mapFactorizationData ‚¶ÉX Y : C‚¶Ñ ‚¶Éf : X ‚ü∂ Y‚¶Ñ (hf : P f) :
    Nonempty (MapFactorizationData Q Q' f)

/-- For every morphism property `P` that is closed under composition with arbitrary morphisms from
the right and has the property that every morphism in `P` can be factored into two morphisms in `P`,
there exists a largest Grothendieck topology with the property that every morphism in `P` belongs to
every covering sieve on its codomain. For the lack of an established name, we call this the
Grothendieck topology generated by `P`. -/
def generatedTopology (P : MorphismProperty C) [P.RespectsRight ‚ä§] [P.HasFactorizationInto P P] :
    GrothendieckTopology C where
  sieves X S := P.toSieveOn X ‚â§ S
  top_mem' X := le_top (a := P.toSieveOn X)
  pullback_stable' X Y S f hS := by
    refine le_trans ?_ (Sieve.pullback_monotone f hS)
    refine (toSieveOn_le_iff _).2 fun Z g hg ‚Ü¶ ?_
    exact Sieve.le_generate _ _ <| RespectsRight.postcomp (Q := ‚ä§) f trivial g hg
  transitive' X S hS R hR := by
    refine (toSieveOn_le_iff R).2 fun Y f hf ‚Ü¶ ?_
    let ‚ü®Z, g, g', hf, hg, hg'‚ü© :=
      HasFactorizationInto.nonempty_mapFactorizationData (Q := P) (Q' := P) hf
    exact hf ‚ñ∏ (toSieveOn_le_iff _).1 (hR <| (toSieveOn_le_iff S).1 hS _ _ hg') _ _ hg

lemma le_generatedTopology_iff {P : MorphismProperty C} [P.RespectsRight ‚ä§]
    [P.HasFactorizationInto P P] (J : GrothendieckTopology C) :
    J ‚â§ P.generatedTopology ‚Üî ‚àÄ X, ‚àÄ S ‚àà J X, ‚àÄ Y (f : Y ‚ü∂ X), P f ‚Üí S f := by
  simp_rw [‚Üê toSieveOn_le_iff]; rfl

/-- The class of all morphisms that factor through `X`, as a `MorphismProperty`. -/
def morphismsThrough (X : C) : MorphismProperty C :=
  fun _ _ f ‚Ü¶ ‚àÉ (g : _ ‚ü∂ X) (g' : X ‚ü∂ _), g ‚â´ g' = f

instance {X : C} : (morphismsThrough X).RespectsLeft ‚ä§ :=
  ‚ü®fun f _ g ‚ü®h, h', hg‚ü© ‚Ü¶ ‚ü®f ‚â´ h, h', by simp [hg]‚ü©‚ü©

instance {X : C} : (morphismsThrough X).RespectsRight ‚ä§ :=
  ‚ü®fun f _ g ‚ü®h, h', hg‚ü© ‚Ü¶ ‚ü®h, h' ‚â´ f, by simp [‚Üê hg]‚ü©‚ü©

instance {X : C} :
    (morphismsThrough X).HasFactorizationInto (morphismsThrough X) (morphismsThrough X) :=
  ‚ü®fun _ _ f ‚ü®g, g', hf‚ü© ‚Ü¶ ‚ü®X, _, _, hf, ‚ü®g, ùüô _, by simp‚ü©, ‚ü®ùüô _, g', by simp‚ü©‚ü©‚ü©

end CategoryTheory.MorphismProperty
