import Mathlib.CategoryTheory.Sites.MorphismProperty

/-!
# Results on morphism properties
Results on morphism properties that should go into `Mathlib.CategoryTheory.Sites.MorphismProperty`
or earlier files.
-/

namespace CategoryTheory.MorphismProperty

open Limits

variable {C : Type*} [Category C]

/-- The presieve on `X` consisting of all morphisms to `X` that satisfy the property `P`. -/
protected def toPresieveOn (P : MorphismProperty C) (X : C) : Presieve X :=
  fun _ f ↦ P f

/-- The sieve on `X` that is generated by `P.toPresieve X`, consisting of all morphisms that factor
through a morphism satisfying `P`. -/
@[simps!]
protected def toSieveOn (P : MorphismProperty C) (X : C) : Sieve X :=
  .generate (P.toPresieveOn X)

lemma toSieveOn_arrows_eq_toPresieveOn {P : MorphismProperty C} [P.RespectsLeft ⊤] {X : C} :
    (P.toSieveOn X).arrows = P.toPresieveOn X := by
  refine (Sieve.le_generate _).antisymm' ?_
  intro Y f ⟨Z, h, g, hg, hf⟩
  exact hf ▸ RespectsLeft.precomp (Q := ⊤) h trivial g hg

lemma toPresieveOn_le_iff {P : MorphismProperty C} {X : C} (S : Presieve X) :
    P.toPresieveOn X ≤ S ↔ ∀ (Y : C) (f : Y ⟶ X), P f → S f :=
  .rfl

lemma toSieveOn_le_iff {P : MorphismProperty C} {X : C} (S : Sieve X) :
    P.toSieveOn X ≤ S ↔ ∀ (Y : C) (f : Y ⟶ X), P f → S f :=
  Sieve.generate_le_iff _ _

/-- Typeclass asserting that every morphism in `P` can be factored as a morphism in `Q` followed by
a morphism in `Q'`. -/
class HasFactorizationInto (P Q Q' : MorphismProperty C) : Prop where
  nonempty_mapFactorizationData {X Y : C} {f : X ⟶ Y} (hf : P f) :
    Nonempty (MapFactorizationData Q Q' f)

/-- For every morphism property `P` that is closed under composition with arbitrary morphisms from
the right and has the property that every morphism in `P` can be factored into two morphisms in `P`,
there exists a largest Grothendieck topology with the property that every morphism in `P` belongs to
every covering sieve on its codomain. For the lack of an established name, we call this the
Grothendieck topology generated by `P`. -/
def generatedTopology (P : MorphismProperty C) [P.RespectsRight ⊤] [P.HasFactorizationInto P P] :
    GrothendieckTopology C where
  sieves X S := P.toSieveOn X ≤ S
  top_mem' X := le_top (a := P.toSieveOn X)
  pullback_stable' X Y S f hS := by
    refine le_trans ?_ (Sieve.pullback_monotone f hS)
    refine (toSieveOn_le_iff _).2 fun Z g hg ↦ ?_
    exact Sieve.le_generate _ _ <| RespectsRight.postcomp (Q := ⊤) f trivial g hg
  transitive' X S hS R hR := by
    refine (toSieveOn_le_iff R).2 fun Y f hf ↦ ?_
    let ⟨Z, g, g', hf, hg, hg'⟩ :=
      HasFactorizationInto.nonempty_mapFactorizationData (Q := P) (Q' := P) hf
    exact hf ▸ (toSieveOn_le_iff _).1 (hR <| (toSieveOn_le_iff S).1 hS _ _ hg') _ _ hg

lemma le_generatedTopology_iff {P : MorphismProperty C} [P.RespectsRight ⊤]
    [P.HasFactorizationInto P P] (J : GrothendieckTopology C) :
    J ≤ P.generatedTopology ↔ ∀ X, ∀ S ∈ J X, ∀ Y (f : Y ⟶ X), P f → S f := by
  simp_rw [← toSieveOn_le_iff]; rfl

end CategoryTheory.MorphismProperty
