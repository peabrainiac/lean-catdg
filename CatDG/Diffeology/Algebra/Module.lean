import CatDG.Diffeology.Algebra.Group

/-!
# Smooth modules
This file introduces diffeological modules and the "fine diffeology",
the finest diffeology turning a given module into a diffeological module.
This is comparable to `Topology.Algebra.Module.ModuleTopology`, although the file
structure and naming are different for historical reasons.

While in practice we mostly care about diffeological vector spaces over `‚Ñù`, we work over
general rings here just in case.

Main definitions / results:
* `DiffeologicalRing R`: typeclass saying that addition, negation and multiplication in
  the ring `R` are smooth
* arbitrary products of diffeological modules are again diffeological modules
* diffeologies induced by linear maps to diffeological modules are module diffeologies
* `ModuleDiffeology R X`: the type of `R`-module diffeologies on `X`. Forms a complete lattice.
* `fineDiffeology R X`: the finest diffeology on `X` making it into a topological `R`-module.
* `fineDiffeology_eq_euclideanDiffeology`: on finite-dimensional real vector spaces, the fine
  diffeology agrees with the standard diffeology for any choice of norm

Note that we do not actually define a typeclass `DiffeologicalModule R X` analogous to
`DiffeologicalGroup` or `DiffeologicalRing` - the reason is such a class could not extend
`DiffeologicalAddGroup X` without breaking typeclass synthesis, because of the extra parameter `R`.
The class would therefore instead have to take in `[DiffeologicalAddGroup X]` as an assumption, but
at that point it would be nothing more than a synonym for `DSmoothSMul R X`. We therefore avoid
defining such a class completely, and instead use `[DiffeologicalAddGroup X] [DSmoothSMul R X]`
whereever we want `X` to be a diffeological module over `R`. This is likely also the reason that
mathlib has no `TopologicalModule` class.

As a consequence, statements like "arbitrary products of diffeological modules are diffeological
modules" and "diffeologies induced by linear maps to diffeological modules are module diffeologies"
also had to be split up into two statements each, one about the underlying additive group and one
about scalar multiplication. Since these lemmas already exist in the respective files, we do not
reintroduce them here.

## TODO
* the fine diffeology is generated by all linear plots
* explicit characterisation of plots of the fine diffeology
* results about the D-topology of the fine diffeology
* is the fine diffeology preserved under products?
-/

/-- A diffeological ring is a ring in which addition, negation and multiplication are smooth. -/
class DiffeologicalRing (R : Type*) [DiffeologicalSpace R] [NonUnitalNonAssocRing R] extends
    DiffeologicalAddGroup R, DSmoothMul R

/-- The main example we care about: `‚Ñù` is a diffeological ring. -/
instance : DiffeologicalRing ‚Ñù where
  dsmooth_add := contDiff_add.dsmooth
  dsmooth_neg := contDiff_neg.dsmooth
  dsmooth_mul := contDiff_mul.dsmooth

instance : DiffeologicalRing ‚ÑÇ where
  dsmooth_add := contDiff_add.dsmooth
  dsmooth_neg := contDiff_neg.dsmooth
  dsmooth_mul := contDiff_mul.dsmooth

/-- Normed spaces with their natural diffeologies are diffeological groups under addition. -/
instance (X : Type*) [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [DiffeologicalSpace X]
    [ContDiffCompatible X] : DiffeologicalAddGroup X where
  dsmooth_add := contDiff_add.dsmooth
  dsmooth_neg := contDiff_neg.dsmooth

/-- Normed spaces with their natural diffeologies are diffeological vector spaces. -/
instance (X : Type*) [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [DiffeologicalSpace X]
    [ContDiffCompatible X] : DSmoothSMul ‚Ñù X where
  dsmooth_smul := contDiff_smul.dsmooth

/-- Every linear map from `Eucl n` into a diffeological vector space is a plot. -/
lemma LinearMap.isPlot (X : Type*) [AddCommGroup X] [Module ‚Ñù X] [DiffeologicalSpace X]
    [DSmoothAdd X] [DSmoothSMul ‚Ñù X] {n : ‚Ñï} (p : Eucl n ‚Üí‚Çó[‚Ñù] X) : IsPlot p := by
  rw [show ‚áëp = fun x ‚Ü¶ ‚àë i, (EuclideanSpace.proj i x) ‚Ä¢ p (EuclideanSpace.single i 1) by
    ext x; convert (p.pi_apply_eq_sum_univ x) using 4; ext i; simp [eq_comm (b := i)]]
  refine (dsmooth_finset_sum _ fun i _ ‚Ü¶ ?_).isPlot
  exact (EuclideanSpace.proj (ùïú := ‚Ñù) i).contDiff.dsmooth.smul dsmooth_const

/-- If a diffeological module is locally compact with respect to the D-topology, then it is
also a topological module. Notice that due to the D-topology not commuting with products
in general, `X` being locally compact is necessary here to ensure that addition and scalar
multiplication are continuous (although for the latter, `R` being locally compact would also
suffice). An example of a diffeological vector space over `‚Ñù` whose addition is
discontinuous is described in https://arxiv.org/abs/2205.09562. -/
example {R : Type*} [Ring R] [DiffeologicalSpace R] [TopologicalSpace R] [DTopCompatible R]
    [DiffeologicalRing R] {X : Type*} [AddCommGroup X] [Module R X] [DiffeologicalSpace X]
    [TopologicalSpace X] [DTopCompatible X] [DiffeologicalAddGroup X] [DSmoothSMul R X]
    [LocallyCompactSpace X] : ContinuousSMul R X ‚àß IsTopologicalAddGroup X :=
  ‚ü®inferInstance, inferInstance‚ü©


/-!
### Lattice of module diffeologies
Analogous to `GroupDiffeology G`, we define for any `R`-module `X` the type
`ModuleDiffeology R X` of all diffeologies that turn `X` into a diffeological module.
This is interesting because, like `DiffeologicalSpace X`, `ModuleDiffeology R X` is
always a complete lattice - its top element is always the indiscrete diffeology, while its
bottom element is generally nontrivial. Note that the discrete diffeology is not a module
diffeology because scalar multiplication fails to be continuous.
-/

/-- A module diffeology on a module `X` is a diffeology with which `X` is a
diffeological module. -/
structure ModuleDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] extends
    DiffeologicalSpace X, DiffeologicalAddGroup X, DSmoothSMul R X

namespace ModuleDiffeology

variable {R : Type*} [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
  {X : Type*} [AddCommGroup X] [Module R X]

def toAddGroupDiffeology (d : ModuleDiffeology R X) : AddGroupDiffeology X :=
  ‚ü®d.toDiffeologicalSpace, d.toDiffeologicalAddGroup‚ü©

/-- A version of the global `dsmooth_add` suitable for dot notation. -/
theorem dsmooth_add' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth fun p : X √ó X ‚Ü¶ p.1 + p.2 :=
  d.toAddGroupDiffeology.dsmooth_add'

/-- A version of the global `dsmooth_neg` suitable for dot notation. -/
theorem dsmooth_neg' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth (Neg.neg : X ‚Üí X) :=
  d.toAddGroupDiffeology.dsmooth_neg'

/-- A version of the global `dsmooth_smul` suitable for dot notation. -/
theorem dsmooth_smul' (d : ModuleDiffeology R X) :
    haveI := d.toDiffeologicalSpace
    DSmooth fun p : R √ó X ‚Ü¶ p.1 ‚Ä¢ p.2 :=
  d.toDSmoothSMul.dsmooth_smul

theorem toDiffeologicalSpace_injective :
    Function.Injective (toDiffeologicalSpace : ModuleDiffeology R X ‚Üí DiffeologicalSpace X) :=
  fun f g h ‚Ü¶ by cases f; cases g; congr

theorem toAddGroupDiffeology_injective :
    Function.Injective (toAddGroupDiffeology : ModuleDiffeology R X ‚Üí AddGroupDiffeology X) :=
  toDiffeologicalSpace_injective.of_comp (f := AddGroupDiffeology.toDiffeologicalSpace)

@[ext]
theorem ext' {d‚ÇÅ d‚ÇÇ : ModuleDiffeology R X} (h : d‚ÇÅ.1 = d‚ÇÇ.1) : d‚ÇÅ = d‚ÇÇ :=
  toDiffeologicalSpace_injective h

instance : PartialOrder (ModuleDiffeology R X) :=
  PartialOrder.lift toDiffeologicalSpace toDiffeologicalSpace_injective

theorem toDiffeologicalSpace_le {d‚ÇÅ d‚ÇÇ : ModuleDiffeology R X} :
    d‚ÇÅ.1 ‚â§ d‚ÇÇ.1 ‚Üî d‚ÇÅ ‚â§ d‚ÇÇ :=
  Iff.rfl

/-- The coarsest module diffeology that is finer than a given diffeology.
Called `reflector` for the lack of a better name and because it is left-adjoint to
`ModuleDiffeology.toDiffeologicalSpace`. -/
def reflector (d : DiffeologicalSpace X) : ModuleDiffeology R X :=
  ‚ü®sInf {d' | d ‚â§ d' ‚àß @DiffeologicalAddGroup X d' _ ‚àß @DSmoothSMul R X _ _ d'},
    diffeologicalAddGroup_sInf fun _ h ‚Ü¶ h.2.1, dsmoothSMul_sInf fun _ h ‚Ü¶ h.2.2‚ü©

lemma gc_toDiffeologicalSpace :
    GaloisConnection reflector (toDiffeologicalSpace (R := R) (X := X)) :=
  fun _ _ ‚Ü¶ ‚ü®fun h ‚Ü¶ (le_sInf fun _ h ‚Ü¶ h.1).trans (toDiffeologicalSpace_le.2 h),
    fun h ‚Ü¶ toDiffeologicalSpace_le.1 <| sInf_le ‚ü®h, toDiffeologicalAddGroup _, toDSmoothSMul _‚ü©‚ü©

/-- The galois insertion between `ModuleDiffeology R X` and `DiffeologicalSpace X` whose
lower part sends each diffeology to the finest coarser module diffeology, and whose
upper part sends each module diffeology to itself. -/
def gci_toDiffeologicalSpace :
    GaloisInsertion reflector (toDiffeologicalSpace (R := R) (X := X)) where
  gc := gc_toDiffeologicalSpace
  le_l_u _ := toDiffeologicalSpace_le.1 <| le_sInf fun _ h ‚Ü¶ h.1
  choice d hd := ‚ü®d, le_antisymm (le_sInf fun _ h ‚Ü¶ h.1) hd ‚ñ∏
    (reflector d).toDiffeologicalAddGroup, le_antisymm (le_sInf fun _ h ‚Ü¶ h.1) hd ‚ñ∏
    (reflector d).toDSmoothSMul‚ü©
  choice_eq _ h := ext' <| le_antisymm (le_sInf fun _ h ‚Ü¶ h.1) h

/-- `R`-module diffeologies on `X` form a complete lattice. -/
instance : CompleteLattice (ModuleDiffeology R X) :=
  (gci_toDiffeologicalSpace).liftCompleteLattice

end ModuleDiffeology

/-!
### The fine diffeology
On any module `X` over a diffeological ring `R`, the fine diffeology is defined as the finest
diffeology making it into a topological module, i.e. the bottom element of
`ModuleDiffeology R X`. Although we do not show it here, the plots of this diffeology are
precisely those maps that locally restrict to smooth maps to finite-dimensional subspaces
of `X` with their standard diffeologies. In particular, on all finite-dimensional normed spaces
this coincides with the smooth diffeology given by the norm - see Zemmour's diffeology book
for more details.

It's not yet clear to me whether the D-topology of this diffeology always coincides with
the finest topology making `X` into a topological module - if it does, it might make sense to
redefine this to make the D-topology defeq to mathlib's `moduleTopology R X`.
-/

section FineDiffeology

/-- The finest diffeology turning a given module over a diffeological ring into a
diffeological module. -/
def fineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] : DiffeologicalSpace X :=
  (‚ä• : ModuleDiffeology R X).toDiffeologicalSpace

/-- A typeclass asserting that the diffeology on `X` equals `fineDiffeology R X`. -/
class IsFineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X] : Prop where
  /-- Slightly awkward because all arguments are implicit - use `eq_fineDiffeology R X` instead. -/
  eq_fineDiffeology' : d = fineDiffeology R X

theorem eq_fineDiffeology (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X]
    [IsFineDiffeology R X] : d = fineDiffeology R X :=
  IsFineDiffeology.eq_fineDiffeology'

instance (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] :
    @IsFineDiffeology R _ _ _ X _ _ (fineDiffeology R X) :=
  letI := fineDiffeology R X; ‚ü®rfl‚ü©

/-- Every module equipped with the fine diffeology is an additive diffeological group.
This unfortunately can't be an instance because the parameter `R` can't be inferred from the
conclusion of the lemma (i.e., when lean is trying to synthesise an instance
`DiffeologicalAddGroup X`, it wouldn't know which ring `R` to use with this lemma). -/
lemma IsFineDiffeology.diffeologicalAddGroup (R : Type*) [DiffeologicalSpace R] [Ring R]
    [DiffeologicalRing R] (X : Type*) [AddCommGroup X] [Module R X] [DiffeologicalSpace X]
    [IsFineDiffeology R X] : DiffeologicalAddGroup X :=
  eq_fineDiffeology R X ‚ñ∏ (‚ä• : ModuleDiffeology R X).toDiffeologicalAddGroup

/-- Since real diffeological vector spaces are the most important special case of diffeological
modules, we register at least `IsFineDiffeology.diffeologicalAddGroup ‚Ñù X` as an instance. -/
instance IsFineDiffeology.diffeologicalAddGroupReal (X : Type*) [AddCommGroup X] [Module ‚Ñù X]
    [DiffeologicalSpace X] [IsFineDiffeology ‚Ñù X] : DiffeologicalAddGroup X :=
  IsFineDiffeology.diffeologicalAddGroup ‚Ñù X

/-- Scalar multiplication is smooth on any module that is equipped with the fine diffeology.
Together with `IsFineDiffeology.diffeologicalAddGroup` this means that every module carrying
the fine diffeology is a diffeological module. -/
instance IsFineDiffeology.dsmoothSMul (R : Type*) [DiffeologicalSpace R] [Ring R]
    [DiffeologicalRing R] (X : Type*) [AddCommGroup X] [Module R X] [DiffeologicalSpace X]
    [IsFineDiffeology R X] : DSmoothSMul R X :=
  eq_fineDiffeology R X ‚ñ∏ (‚ä• : ModuleDiffeology R X).toDSmoothSMul

/-- The fine diffeology is finer than any other diffeology making `X` a diffeological module. -/
lemma fineDiffeology_le (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    (X : Type*) [AddCommGroup X] [Module R X] [d : DiffeologicalSpace X]
    [DiffeologicalAddGroup X] [DSmoothSMul R X]: fineDiffeology R X ‚â§ d :=
  ModuleDiffeology.toDiffeologicalSpace_le.2
    (bot_le : (‚ä• : ModuleDiffeology R X) ‚â§ ‚ü®d, inferInstance, inferInstance‚ü©)

/-- Any linear map from a fine diffeological module to another diffeological module is smooth. -/
lemma LinearMap.dsmooth (R : Type*) [DiffeologicalSpace R] [Ring R] [DiffeologicalRing R]
    {X : Type*} [AddCommGroup X] [Module R X] [DiffeologicalSpace X] [IsFineDiffeology R X]
    {Y : Type*} [AddCommGroup Y] [Module R Y] [DiffeologicalSpace Y] [DiffeologicalAddGroup Y]
    [DSmoothSMul R Y] (f : X ‚Üí‚Çó[R] Y) : DSmooth f :=
  dsmooth_iff_le_induced.2 <| (eq_fineDiffeology R X (d := _)).trans_le <|
    @fineDiffeology_le R _ _ _ X _ _ (.induced f _) (diffeologicalAddGroup_induced f)
      (dsmoothSMul_induced f dsmooth_id (map_smul f _ _))

/-- On finite-dimensional normed spaces, the fine diffeology equals the standard diffeology
consisting of plots that are smooth with respect to the norm. Since the fine diffeology does
not depend on any norm, this in particular shows that `euclideanDiffeology` does not actually
depend on the choice of norm either. -/
lemma fineDiffeology_eq_euclideanDiffeology (X : Type*) [NormedAddCommGroup X] [NormedSpace ‚Ñù X]
    [FiniteDimensional ‚Ñù X] : fineDiffeology ‚Ñù X = euclideanDiffeology := by
  refine le_antisymm (@fineDiffeology_le ‚Ñù _ _ _ X _ _ (_) _ _) ?_
  rw [DiffeologicalSpace.le_iff']; intro n p hp
  let e := LinearEquiv.ofFinrankEq X (Eucl _) (finrank_euclideanSpace_fin.symm)
  rw [show p = e.symm ‚àò e ‚àò p by
    rw [‚Üê Function.comp_assoc]; convert p.id_comp.symm; exact e.toEquiv.symm_comp_self]
  let _ := fineDiffeology ‚Ñù X
  refine isPlot_reparam e.symm.toLinearMap.isPlot ?_
  exact (LinearMap.toContinuousLinearMap e.toLinearMap).contDiff.comp hp

instance {X : Type*} [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [FiniteDimensional ‚Ñù X]
    [DiffeologicalSpace X] [IsFineDiffeology ‚Ñù X] : ContDiffCompatible X := by
  rw [eq_fineDiffeology ‚Ñù X, fineDiffeology_eq_euclideanDiffeology X]
  infer_instance

instance {X : Type*} [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [FiniteDimensional ‚Ñù X]
    [DiffeologicalSpace X] [ContDiffCompatible X] : IsFineDiffeology ‚Ñù X := by
  constructor; rw [fineDiffeology_eq_euclideanDiffeology X]
  exact contDiffCompatible_iff_eq_euclideanDiffeology.1 (by assumption)

end FineDiffeology
